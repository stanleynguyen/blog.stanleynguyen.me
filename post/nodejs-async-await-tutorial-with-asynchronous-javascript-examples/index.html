<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width"><script type=application/javascript src=https://blog.stanleynguyen.me/js/theme-mode.js></script><link rel=stylesheet href=https://blog.stanleynguyen.me/css/frameworks.min.css><link rel=stylesheet href=https://blog.stanleynguyen.me/css/github.min.css><link rel=stylesheet href=https://blog.stanleynguyen.me/css/github-style.css><link rel=stylesheet href=https://blog.stanleynguyen.me/css/light.css><link rel=stylesheet href=https://blog.stanleynguyen.me/css/dark.css><link rel=stylesheet href=https://blog.stanleynguyen.me/css/syntax.css><title>Node.js Async Await Tutorial ‚Äì With Asynchronous JavaScript Examples - Personal blog of Stanley Nguyen | software engineer & open-source enthusiast</title><link rel=icon type=image/x-icon href=https://blog.stanleynguyen.me/images/favicon.ico><meta name=theme-color content="#1e2327"><meta name=description content="A complete guide to Node.js async await"><meta name=keywords content="nodejs,async,await,javascript"><meta name=robots content="noodp"><link rel=canonical href=https://blog.stanleynguyen.me/post/nodejs-async-await-tutorial-with-asynchronous-javascript-examples/><meta name=twitter:card content="summary"><meta name=twitter:title content="Node.js Async Await Tutorial ‚Äì With Asynchronous JavaScript Examples - Personal blog of Stanley Nguyen | software engineer & open-source enthusiast"><meta name=twitter:description content="A complete guide to Node.js async await"><meta name=twitter:site content="https://blog.stanleynguyen.me/"><meta name=twitter:creator content="stanleynguyen"><meta name=twitter:image content="https://blog.stanleynguyen.me/post/nodejs-async-await-tutorial-with-asynchronous-javascript-examples/img/yoda.jpeg"><meta property="og:type" content="article"><meta property="og:title" content="Node.js Async Await Tutorial ‚Äì With Asynchronous JavaScript Examples - Personal blog of Stanley Nguyen | software engineer & open-source enthusiast"><meta property="og:description" content="A complete guide to Node.js async await"><meta property="og:url" content="https://blog.stanleynguyen.me/post/nodejs-async-await-tutorial-with-asynchronous-javascript-examples/"><meta property="og:site_name" content="Node.js Async Await Tutorial ‚Äì With Asynchronous JavaScript Examples"><meta property="og:image" content="https://blog.stanleynguyen.me/post/nodejs-async-await-tutorial-with-asynchronous-javascript-examples/img/yoda.jpeg"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2021-05-04 00:00:00 +0800 +0800"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-167295669-2"></script><script>if(navigator.doNotTrack!=='1'){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-167295669-2');}</script><link rel=icon type=image/x-icon class=js-site-favicon href=https://blog.stanleynguyen.me/%20favicon.ico><meta name=monetization content="$ilp.uphold.com/X2qLwibKrnFM"><style>figure{margin:1em 40px;display:flex;flex-direction:column;align-items:center}figcaption{margin-top:10px}figcaption p{color:#6a737d}</style></head><body><div style=position:relative><header class="Header js-details-container Details px-3 px-md-4 px-lg-5 flex-wrap flex-md-nowrap open Details--on"><div class="Header-item mobile-none" style=margin-top:-4px;margin-bottom:-4px><a class=Header-link href=https://blog.stanleynguyen.me/><svg class="octicon" height="32" viewBox="0 0 16 16" width="32"><path fill-rule="evenodd" d="M8 0C3.58.0.0 3.58.0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38.0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95.0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12.0.0.67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15.0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48.0 1.07-.01 1.93-.01 2.2.0.21.15.46.55.38A8.013 8.013.0 0016 8c0-4.42-3.58-8-8-8z"/></svg></a></div><div class="Header-item d-md-none"><button class="Header-link btn-link js-details-target" type=button onclick="document.querySelector('#header-search').style.display=document.querySelector('#header-search').style.display=='none'?'block':'none'"><svg height="24" class="octicon octicon-three-bars" viewBox="0 0 16 16" width="24"><path fill-rule="evenodd" d="M1 2.75A.75.75.0 011.75 2h12.5a.75.75.0 110 1.5H1.75A.75.75.0 011 2.75zm0 5A.75.75.0 011.75 7h12.5a.75.75.0 110 1.5H1.75A.75.75.0 011 7.75zM1.75 12a.75.75.0 100 1.5h12.5a.75.75.0 100-1.5H1.75z"/></svg></button></div><div style=display:none id=header-search class="Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-0 mr-md-3 mt-3 mt-md-0 Details-content--hidden-not-important d-md-flex"><div class="Header-search header-search flex-auto js-site-search position-relative flex-self-stretch flex-md-self-auto mb-3 mb-md-0 mr-0 mr-md-3 scoped-search site-scoped-search js-jump-to"><div class=position-relative><form target=_blank action=https://www.google.com/search accept-charset=utf-8 method=get autocomplete=off><label class="Header-search-label form-control input-sm header-search-wrapper p-0 js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center"><input type=text class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable" name=q placeholder=Search autocomplete=off>
<input type=hidden name=q value=site:https://blog.stanleynguyen.me/></label></form></div></div></div><div class="Header-item Header-item--full flex-justify-center d-md-none position-relative"><a class=Header-link href=https://blog.stanleynguyen.me/><svg class="octicon octicon-mark-github v-align-middle" height="32" viewBox="0 0 16 16" width="32"><path fill-rule="evenodd" d="M8 0C3.58.0.0 3.58.0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38.0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95.0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12.0.0.67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15.0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48.0 1.07-.01 1.93-.01 2.2.0.21.15.46.55.38A8.013 8.013.0 0016 8c0-4.42-3.58-8-8-8z"/></svg></a></div><div class=Header-item style=margin-right:0><a href=javascript:void(0) class="Header-link no-select" onclick=switchTheme()><svg style="fill:var(--color-profile-color-modes-toggle-moon)" class="no-select" viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.52208 7.71754c3.05612.0 5.53362-2.47748 5.53362-5.5336C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961 9.95801 1.07727 10.3495.771159 10.6474.99992 12.1153 2.12716 13.0615 3.89999 13.0615 5.89383 13.0615 9.29958 10.3006 12.0605 6.89485 12.0605c-2.94151.0-5.40199-2.0595-6.018122-4.81523C.794841 6.87902 1.23668 6.65289 1.55321 6.85451 2.41106 7.40095 3.4296 7.71754 4.52208 7.71754z"/></svg></a></div></header></div><div><main><div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4"><div class=px-0><div class="mb-3 d-flex px-3 px-md-3 px-lg-5"><div class="flex-auto min-width-0 width-fit mr-3"><div class=d-flex><div class="d-none d-md-block"><a class="avatar mr-2 flex-shrink-0" href=https://blog.stanleynguyen.me/><img class=avatar-user src=https://unavatar.now.sh/github/stanleynguyen width=32 height=32></a></div><div class="d-flex flex-column"><h1 class="break-word f3 text-normal mb-md-0 mb-1"><span class=author><a href=https://blog.stanleynguyen.me/>Stanley Nguyen</a></span><span class=path-divider>/</span><strong class="css-truncate-target mr-1" style=max-width:410px><a href=https://blog.stanleynguyen.me/post/nodejs-async-await-tutorial-with-asynchronous-javascript-examples/>Node.js Async Await Tutorial ‚Äì With Asynchronous JavaScript Examples</a></strong></h1><div class="note m-0">Created <relative-time datetime="Tue, 04 May 2021 00:00:00 +0800" class=no-wrap>Tue, 04 May 2021 00:00:00 +0800</relative-time></div></div></div></div></div></div></div><div class="container-lg px-3 new-discussion-timeline"><div class="repository-content gist-content"><div><div class="js-gist-file-update-container js-task-list-container file-box"><div id=file-pytest class="file my-2"><div class="file-header d-flex flex-md-items-center flex-items-start"><div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto"><div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0">2078 Words</div><div class="file-actions flex-order-2 pt-0"></div></div></div><div class="Box-body px-5 pb-5"><article class="markdown-body entry-content container-lg"><p>One of the hardest concepts to wrap our heads around when we first learn JavaScript
is the asynchronous processing model of the language.
For the majority of us, learning asynchronous programming looks pretty much like this</p><figure><img src=img/async.png alt="If your first time working with async wasn&amp;rsquo;t like this, please consider yourself a genius" width=500><figcaption><p>If your first time working with async wasn&rsquo;t like this, please consider yourself a genius</p></figcaption></figure><p>As much as hard as it is to pick up, async programming is critical to whoever want to use JavaScript/Node.js to build web applications and servers as JS codes are <strong>asynchronous by default</strong>.</p><h2 id=the-fundamentals>The fundamentals</h2><p>So what exactly is asynchronous processing model, or <code>non-blocking I/O</code> model which
we must all have heard of as Node.js users?
A tl;dr description for it would be that: In an async processing model,
our application engine when interacting with external parties (e.g. file system,
network), instead of waiting til it&rsquo;s got a result from the external parties, continues
with to subsequent tasks and only come back to the prior external parties once it&rsquo;s
got a signal of a result.</p><p>To understand the default async processing model of Node.js, let&rsquo;s have a look at
a hypothetical Santa&rsquo;s workshop. Before any work can begin, Santa will have to read
each of the lovely letters from kids around the world.</p><p><img src=img/santa-01.png alt="Santa reading letter for workshop"></p><p>He will then deduce the requested gift, translate the item name into
<a href=https://en.wikipedia.org/wiki/Elvish_languages>the Elvish language</a>, and then pass
the instruction to each of our hard working elves who have different specialisations:
wooden toys for Red, stuffed toys for Blue, and robotic toys for Green.</p><p><img src=img/santa-02.png alt="Santa passing instruction to Red"></p><p>This year, due to <a href=https://en.wikipedia.org/wiki/COVID-19_pandemic>the COVID-19 pandemic</a>,
only half Santa&rsquo;s elves can come to his workshop to help. Nonetheless, as wise as he is,
Santa decides that, instead of waiting for each elf to finish preparing a gift (i.e. synchronously),
he will continue translating and passing out instructions from his pile of letters.</p><p><img src=img/santa-03.png alt="Santa passing instruction to Blue"></p><p>So on and so for&mldr;</p><p><img src=img/santa-04.png alt="Santa continue passing out instructions"></p><p>As he is just about to read another letter, Red informs Santa that he has completed
preparing the first gift. Santa then receives the present from Red, put it to one side&mldr;</p><p><img src=img/santa-05.png alt="Santa receiving Red&rsquo;s present"></p><p>&mldr;before continuing with translating and passing instructions from the next letter.</p><p><img src=img/santa-06.png alt="Santa passing instruction to Green"></p><p>As he only needs to wrap a pre-made flying robot, Green can quickly finish preparation and pass
the present to Santa.</p><p><img src=img/santa-07.png alt="Santa receiving Green&rsquo;s present"></p><p>After a whole day of hard and asynchronous work, Santa and the elves manage to complete
all present preparation. With his improved asynchronous model of working, Santa
workshop is completed in record time despite being hard-hitted by the pandemic.</p><p><img src=img/santa-08.png alt="Santa&rsquo;s gotten all the presents"></p><p>So that&rsquo;s the basic idea of asynchronous or non-blocking I/O processing model.
How is this done in Node.js specifically?</p><h2 id=the-nodejs-event-loop>The Node.js event loop</h2><p>Most of us would probably have heard before that &ldquo;Node.js is single-threaded&rdquo;.
However, to be exact, only the event loop in Node.js, which interacts with a pool
of background C++ worker threads, is single-threaded.
There&rsquo;re 4 important components to the Node.js processing model:</p><ul><li>Event Queue: Tasks that are declared in a program, or returned from the processing
thread pool via <a href=https://nodejs.org/en/knowledge/getting-started/control-flow/what-are-callbacks/>callbacks</a>
(The equivalent of this in our Santa&rsquo;s workshop is the pile of letters for Santa)</li><li>Event Loop: The main Node.js thread that facilitate event queue and worker thread
pool to carry out operations - both async and synchronous. (This is Santa üéÖ)</li><li>Background thread pool: These theads do the actual processing of tasks, which
might be I/O blocking (e.g. calling and waiting for response from an external API).
(These are the hardworking elves üßùüßù‚Äç‚ôÄÔ∏èüßù‚Äç‚ôÇÔ∏è from our workshop)</li></ul><p>This processing model can be visualised as below:</p><figure><img src=img/processing-model.png alt="Diagram courtesy of c-sharpcorner.com"><figcaption><p>Diagram courtesy of c-sharpcorner.com</p></figcaption></figure><p>Let&rsquo;s look at an actual snippet of code to see these above in action</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Hello&#34;</span>);
<span style=color:#a6e22e>https</span>.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;https://httpstat.us/200&#34;</span>, (<span style=color:#a6e22e>res</span>) =&gt; {
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`API returned status: </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>statusCode</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
});
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;from the other side&#34;</span>);
</code></pre></div><p>If we execute the above piece of code, we would get this in our standard output</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>Hello
from the other side
API returned status: <span style=color:#ae81ff>200</span>
</code></pre></div><p>So how does the Node.js engine carries out the above snippet of code? It starts
with 3 functions in the call stack.</p><p><img src=img/execution-01.png alt="Processing starts with 3 functions in the call stack"></p><p>&ldquo;Hello&rdquo; is then printed to the console with the corresponding function call removed
from the stack.</p><p><img src=img/execution-02.png alt="Hello console log removed from stack"></p><p>The function call to <code>https.get</code> (i.e. making a get request to the corresponding
URL) is then executed and delegated to the worker thread pool with a callback attached.</p><p><img src=img/execution-03.png alt="https.get delegated to worker pool"></p><p>The next function call to <code>console.log</code> get executed and &ldquo;from the other side&rdquo; is
printed to the console.</p><p><img src=img/execution-04.png alt="Next console.log get executed"></p><p>Now that the network call has return a response, the callback function call will
then get queued inside the callback queue. Note that this step could, though normally
is not the case, happen before the immediate previous step (i.e. &ldquo;from the other
side&rdquo; getting printed).</p><p><img src=img/execution-05.png alt="Network call completes and callback queued"></p><p>The callback then get put inside our call stack</p><p><img src=img/execution-06.png alt="Callback put inside call stack"></p><p>and then we will see &ldquo;API returned status: 200&rdquo; in our console</p><p><img src=img/execution-07.png alt="Status code printed out"></p><p>By facilitating the callback queue and call stack, the event loop in Node.js
efficiently execute our JavaScript code in an asynchronous manner.</p><h2 id=a-synchronous-history-of-javascript--nodejs-asyncawait>A synchronous history of JavaScript & Node.js async/await</h2><p>Now that we have grasped a good understanding into asynchronous execution and the
innerworkings of Node.js event loop, let&rsquo;s dive into the async/await implementations
of JavaScript through time, from the origin callback-driven implementation to the
latest shiny async/await keywords.</p><h3 id=callbacks>Callbacks</h3><p>The OG way of handling asynchronous nature of JavaScript engines are through callbacks.
Callbacks are basically functions which will be executed, <strong>usually</strong>, at the end
of synchronous or I/O blocking operations. A straightforward example of this pattern
is the built-in <code>setTimeout</code> function that will wait for a certain number of milliseconds
before executing the callback.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#a6e22e>setTimeout</span>(<span style=color:#ae81ff>2000</span>, () =&gt; {
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Hello&#34;</span>);
});
</code></pre></div><p>While it&rsquo;s convenient to just attach callbacks to blocking operations, this pattern
also introduces a couple of problems:</p><ul><li>Callback hell</li><li>Inversion of control (not the good kind!!)</li></ul><h4 id=callback-hell>Callback hell</h4><p>Let&rsquo;s have an example with our Santa and his elves again. To prepare a present,
Santa&rsquo;s workshop would have to carry out a few different steps (with each take
different durations simulated using <code>setTimeout</code>)</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>translateLetter</span>(<span style=color:#a6e22e>letter</span>, <span style=color:#a6e22e>callback</span>) {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>setTimeout</span>(<span style=color:#ae81ff>2000</span>, () =&gt; {
    <span style=color:#a6e22e>callback</span>(<span style=color:#a6e22e>letter</span>.<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#34;&#34;</span>).<span style=color:#a6e22e>reverse</span>().<span style=color:#a6e22e>join</span>(<span style=color:#e6db74>&#34;&#34;</span>));
  });
}
<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>assembleToy</span>(<span style=color:#a6e22e>instruction</span>, <span style=color:#a6e22e>callback</span>) {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>setTimeout</span>(<span style=color:#ae81ff>3000</span>, () =&gt; {
    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>toy</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>instruction</span>.<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#34;&#34;</span>).<span style=color:#a6e22e>reverse</span>().<span style=color:#a6e22e>join</span>(<span style=color:#e6db74>&#34;&#34;</span>);
    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>toy</span>.<span style=color:#a6e22e>includes</span>(<span style=color:#e6db74>&#34;wooden&#34;</span>)) {
      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>callback</span>(<span style=color:#e6db74>`polished </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>toy</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>toy</span>.<span style=color:#a6e22e>includes</span>(<span style=color:#e6db74>&#34;stuffed&#34;</span>)) {
      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>callback</span>(<span style=color:#e6db74>`colorful </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>toy</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>toy</span>.<span style=color:#a6e22e>includes</span>(<span style=color:#e6db74>&#34;robotic&#34;</span>)) {
      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>callback</span>(<span style=color:#e6db74>`flying </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>toy</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
    }
    <span style=color:#a6e22e>callback</span>(<span style=color:#a6e22e>toy</span>);
  });
}
<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>wrapPresent</span>(<span style=color:#a6e22e>toy</span>, <span style=color:#a6e22e>callback</span>) {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>setTimeout</span>(<span style=color:#ae81ff>1000</span>, () =&gt; {
    <span style=color:#a6e22e>callback</span>(<span style=color:#e6db74>`wrapped </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>toy</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
  });
}
</code></pre></div><p>These steps need to be carried out in a specific order</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#a6e22e>translateLetter</span>(<span style=color:#e6db74>&#34;wooden truck&#34;</span>, (<span style=color:#a6e22e>instruction</span>) =&gt; {
  <span style=color:#a6e22e>assembleToy</span>(<span style=color:#a6e22e>instruction</span>, (<span style=color:#a6e22e>toy</span>) =&gt; {
    <span style=color:#a6e22e>wrapPresent</span>(<span style=color:#a6e22e>toy</span>, <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>);
  });
});
<span style=color:#75715e>// This will produced a &#34;wrapped polished wooden truck&#34; as the final result
</span></code></pre></div><p>As we do things this way, adding more steps to the process would mean pushing the
inner callbacks rightward and ending up with a callback hell like this.</p><figure><img src=img/callback-hell.jpeg alt="Callback Hell"></figure><p>Callbacks look very sequential but at times the execution order doesn&rsquo;t follow
what shown on our screen. With multiple layers of nested callbacks, we will lose
track of the big picture of the whole program flow and produce more bugs or just
become slower when writing our code.</p><p>So how do we solve this problem? Simply modularise the nested callbacks into named
functions and we will have a nicely left-aligned program that&rsquo;s easy to read.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>assembleCb</span>(<span style=color:#a6e22e>toy</span>) {
  <span style=color:#a6e22e>wrapPresent</span>(<span style=color:#a6e22e>toy</span>, <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>);
}
<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>translateCb</span>(<span style=color:#a6e22e>instruction</span>) {
  <span style=color:#a6e22e>assembleToy</span>(<span style=color:#a6e22e>instruction</span>, <span style=color:#a6e22e>assembleCb</span>);
}
<span style=color:#a6e22e>translateLetter</span>(<span style=color:#e6db74>&#34;wooden truck&#34;</span>, <span style=color:#a6e22e>translateCb</span>);
</code></pre></div><h4 id=inversion-of-control>Inversion of Control</h4><p>Another problem with the callback pattern is that we don&rsquo;t decide how the
higher-order functions would execute our callbacks. They might execute it at
the end of the function, which is conventional, but they could also execute it
at the start of the function or execute it multiple times. Basically, we are at
the mercy of our dependency owners, we might never know when they will break our
code.</p><p>To solve this problem, as a dependency user, there&rsquo;s not much we can do about it.
However, if we&rsquo;re ever in the seat of a dependency owner, please always:</p><ul><li>Stick to the conventional callback signature with error as the first argument</li><li>Execute callback only once at the end of your higher-order function</li><li>Document anything out-of-convention that are absolutely required and always
aim for backward compatibility</li></ul><h3 id=promises>Promises</h3><p><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise>Promises</a>
were created to solve these above mentioned problems with callbacks.
Promises enforce JavaScript users to:</p><ul><li>Stick to a specific convention with their signature <code>resolve</code> and <code>reject</code> functions.</li><li>Chain the callback functions to a well-aligned and top-down flow.</li></ul><p>Our previous example with Santa&rsquo;s workshop preparing presents can be rewritten with
promises like so</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>translateLetter</span>(<span style=color:#a6e22e>letter</span>) {
  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Promise((<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>reject</span>) =&gt; {
    <span style=color:#a6e22e>setTimeout</span>(<span style=color:#ae81ff>2000</span>, () =&gt; {
      <span style=color:#a6e22e>resolve</span>(<span style=color:#a6e22e>letter</span>.<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#34;&#34;</span>).<span style=color:#a6e22e>reverse</span>().<span style=color:#a6e22e>join</span>(<span style=color:#e6db74>&#34;&#34;</span>));
    });
  });
}
<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>assembleToy</span>(<span style=color:#a6e22e>instruction</span>) {
  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Promise((<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>reject</span>) =&gt; {
    <span style=color:#a6e22e>setTimeout</span>(<span style=color:#ae81ff>3000</span>, () =&gt; {
      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>toy</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>instruction</span>.<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#34;&#34;</span>).<span style=color:#a6e22e>reverse</span>().<span style=color:#a6e22e>join</span>(<span style=color:#e6db74>&#34;&#34;</span>);
      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>toy</span>.<span style=color:#a6e22e>includes</span>(<span style=color:#e6db74>&#34;wooden&#34;</span>)) {
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>resolve</span>(<span style=color:#e6db74>`polished </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>toy</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
      } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>toy</span>.<span style=color:#a6e22e>includes</span>(<span style=color:#e6db74>&#34;stuffed&#34;</span>)) {
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>resolve</span>(<span style=color:#e6db74>`colorful </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>toy</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
      } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>toy</span>.<span style=color:#a6e22e>includes</span>(<span style=color:#e6db74>&#34;robotic&#34;</span>)) {
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>resolve</span>(<span style=color:#e6db74>`flying </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>toy</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
      }
      <span style=color:#a6e22e>resolve</span>(<span style=color:#a6e22e>toy</span>);
    });
  });
}
<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>wrapPresent</span>(<span style=color:#a6e22e>toy</span>) {
  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Promise((<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>reject</span>) =&gt; {
    <span style=color:#a6e22e>setTimeout</span>(<span style=color:#ae81ff>1000</span>, () =&gt; {
      <span style=color:#a6e22e>resolve</span>(<span style=color:#e6db74>`wrapped </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>toy</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
    });
  });
}
</code></pre></div><p>with the steps being carried out nicely in a chain</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#a6e22e>translateLetter</span>(<span style=color:#e6db74>&#34;wooden truck&#34;</span>)
  .<span style=color:#a6e22e>then</span>((<span style=color:#a6e22e>instruction</span>) =&gt; {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>assembleToy</span>(<span style=color:#a6e22e>instruction</span>);
  })
  .<span style=color:#a6e22e>then</span>((<span style=color:#a6e22e>toy</span>) =&gt; {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>wrapPresent</span>(<span style=color:#a6e22e>toy</span>);
  })
  .<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>);
<span style=color:#75715e>// This would produce the exact same present: wrapped polished wooden truck
</span></code></pre></div><p>However, promises are not without problems either. Data in each eye of our chain
have a different scope and only have access data passed from the immediate previous
step or parent scope. For example, our gift-wrapping step might want to use data
from the translation step</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>wrapPresent</span>(<span style=color:#a6e22e>toy</span>, <span style=color:#a6e22e>instruction</span>) {
  <span style=color:#66d9ef>return</span> Promise((<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>reject</span>) =&gt; {
    <span style=color:#a6e22e>setTimeout</span>(<span style=color:#ae81ff>1000</span>, () =&gt; {
      <span style=color:#a6e22e>resolve</span>(<span style=color:#e6db74>`wrapped </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>toy</span><span style=color:#e6db74>}</span><span style=color:#e6db74> with instruction: &#34;</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>instruction</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
    });
  });
}
</code></pre></div><p>This is rather <a href=https://livebook.manning.com/book/c-plus-plus-concurrency-in-action/chapter-3/1>a classic &ldquo;memory sharing&rdquo; problem with threading</a>. To solve this, instead of using variables in the parents scope, we
should make use of <code>Promise.all</code> and <a href=https://blog.golang.org/codelab-share>&ldquo;share data by communicating, rather than communicate by sharing data&rdquo;</a>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#a6e22e>translateLetter</span>(<span style=color:#e6db74>&#34;wooden truck&#34;</span>)
  .<span style=color:#a6e22e>then</span>((<span style=color:#a6e22e>instruction</span>) =&gt; {
    <span style=color:#66d9ef>return</span> Promise.<span style=color:#a6e22e>all</span>([<span style=color:#a6e22e>assembleToy</span>(<span style=color:#a6e22e>instruction</span>), <span style=color:#a6e22e>instruction</span>]);
  })
  .<span style=color:#a6e22e>then</span>((<span style=color:#a6e22e>toy</span>, <span style=color:#a6e22e>instruction</span>) =&gt; {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>wrapPresent</span>(<span style=color:#a6e22e>toy</span>, <span style=color:#a6e22e>instruction</span>);
  })
  .<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>);
<span style=color:#75715e>// This would produce the present: wrapped polished wooden truck with instruction: &#34;kcurt nedoow&#34;
</span></code></pre></div><h3 id=asyncawait>Async/Await</h3><p>Last but definitely not least, the shiniest kid around the block - async/await - is
very easy to use but also carries some risk of misuse.</p><p>Async/await solves the memory sharing problems of promises by having everything
under the same scope. Our previous example can be rewritten easily like so</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js>(<span style=color:#a6e22e>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>main</span>() {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>instruction</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>translateLetter</span>(<span style=color:#e6db74>&#34;wooden truck&#34;</span>);
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>toy</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>assembleToy</span>(<span style=color:#a6e22e>instruction</span>);
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>present</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>wrapPresent</span>(<span style=color:#a6e22e>toy</span>, <span style=color:#a6e22e>instruction</span>);
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>present</span>);
})();
<span style=color:#75715e>// This would produce the present: wrapped polished wooden truck with instruction: &#34;kcurt nedoow&#34;
</span></code></pre></div><p>However, as much as it&rsquo;s easy to write asynchronous code with async/await, it&rsquo;s
easy to make mistakes that create performance loopholes. Let&rsquo;s now localise our
example Santa&rsquo;s workshop scenario to wrapping presents and loading them on the sleigh.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>wrapPresent</span>(<span style=color:#a6e22e>toy</span>) {
  <span style=color:#66d9ef>return</span> Promise((<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>reject</span>) =&gt; {
    <span style=color:#a6e22e>setTimeout</span>(<span style=color:#ae81ff>5000</span> <span style=color:#f92672>*</span> Math.<span style=color:#a6e22e>random</span>(), () =&gt; {
      <span style=color:#a6e22e>resolve</span>(<span style=color:#e6db74>`wrapped </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>toy</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
    });
  });
}
<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>loadPresents</span>(<span style=color:#a6e22e>presents</span>) {
  <span style=color:#66d9ef>return</span> Promise((<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>reject</span>) =&gt; {
    <span style=color:#a6e22e>setTimeout</span>(<span style=color:#ae81ff>5000</span>, () =&gt; {
      <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>itemList</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>;
      <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>presents</span>.<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
        <span style=color:#a6e22e>itemList</span> <span style=color:#f92672>+=</span> <span style=color:#e6db74>`</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>i</span><span style=color:#e6db74>}</span><span style=color:#e6db74>. </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>presents</span>[<span style=color:#a6e22e>i</span>]<span style=color:#e6db74>}</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#e6db74>n`</span>;
      }
    });
  });
}
</code></pre></div><p>A common mistake that we would make is carrying out the steps this way</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js>(<span style=color:#a6e22e>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>main</span>() {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>presents</span> <span style=color:#f92672>=</span> [];
  <span style=color:#a6e22e>presents</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>await</span> <span style=color:#a6e22e>wrapPresent</span>(<span style=color:#e6db74>&#34;wooden truck&#34;</span>));
  <span style=color:#a6e22e>presents</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>await</span> <span style=color:#a6e22e>wrapPresent</span>(<span style=color:#e6db74>&#34;flying robot&#34;</span>));
  <span style=color:#a6e22e>presents</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>await</span> <span style=color:#a6e22e>wrapPresent</span>(<span style=color:#e6db74>&#34;stuffed elephant&#34;</span>));
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>itemList</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>loadPresents</span>(<span style=color:#a6e22e>presents</span>);
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>itemList</span>);
})();
</code></pre></div><p>But does Santa needs to <code>await</code> for each of the presents to be wrapped one by one
before loading? Definitely not! The presents should be wrapped concurrently.
We often make the mistake as it&rsquo;s so easy to write <code>await</code> without thinking about
the blocking nature of the keyword.</p><p>To solve this problem, we should bundle the gift wrapping steps together and execute
them all at once</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js>(<span style=color:#a6e22e>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>main</span>() {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>presents</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> Promise.<span style=color:#a6e22e>all</span>([
    <span style=color:#a6e22e>wrapPresent</span>(<span style=color:#e6db74>&#34;wooden truck&#34;</span>),
    <span style=color:#a6e22e>wrapPresent</span>(<span style=color:#e6db74>&#34;flying robot&#34;</span>),
    <span style=color:#a6e22e>wrapPresent</span>(<span style=color:#e6db74>&#34;stuffed elephant&#34;</span>),
  ]);
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>itemList</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>loadPresents</span>(<span style=color:#a6e22e>presents</span>);
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>itemList</span>);
})();
</code></pre></div><p>Some recommended steps to tackle concurrency performance issue in our Node.js code are:</p><ul><li>Identify hotspots with multiple consecutive await in our code</li><li>Check if they have dependencies on each other (i.e. one function uses data returned from another)</li><li>Make independent function calls concurrent with <code>Promise.all</code></li></ul><h2 id=wrapping-up-the-article-not-christmas-presents->Wrapping up (the article, not Christmas presents üòÇ)</h2><p>Congratulations on reaching the end of this article, I tried my best to make
this post shorter but the async topic in JavaScript is just so broad. Some tl;dr
key takeaways:</p><ul><li>Modularise our JavaScript callbacks to avoid callback hell</li><li>Stick to <a href=https://gist.github.com/sunnycmf/b2ad4f80a3b627f04ff2>the convention for JS callbacks</a></li><li>Sharing data by communicating through <code>Promise.all</code> when using promises</li><li>Be careful about the performance implication of async/await code</li><li>We ‚ù§Ô∏è JavaScript</li></ul></article></div></div></div></div></div></div></main></div><div class="footer container-xl width-full p-responsive"><div class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-lg-justify-between flex-sm-items-center pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light"><a aria-label=Homepage title=GitHub class="footer-octicon d-none d-lg-block mr-lg-4" href=https://blog.stanleynguyen.me/><svg height="24" class="octicon octicon-mark-github" viewBox="0 0 16 16" width="24"><path fill-rule="evenodd" d="M8 0C3.58.0.0 3.58.0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38.0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95.0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12.0.0.67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15.0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48.0 1.07-.01 1.93-.01 2.2.0.21.15.46.55.38A8.013 8.013.0 0016 8c0-4.42-3.58-8-8-8z"/></svg></a><ul class="list-style-none d-flex flex-wrap col-12 flex-justify-center flex-lg-justify-between mb-2 mb-lg-0"><li class="mr-3 mr-lg-0">¬© 2021. Theme by <a href=https://github.com/MeiK2333/github-style><span>github-style</span></a></li></ul></div><div class="d-flex flex-justify-center pb-6"><span class="f6 text-gray-light"></span></div></div></body><script type=application/javascript src=https://blog.stanleynguyen.me/js/github-style.js></script></html>